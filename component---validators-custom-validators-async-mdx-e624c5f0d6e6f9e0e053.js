(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{"3Zug":function(e,a,t){e.exports=t.p+"static/async-validator-04bec2a4817d277fbe5059a6a969ee82.gif"},Xz34:function(e,a,t){e.exports=t.p+"static/async-record-validator-f990b733ddffc318db73b8a4f63db62c.gif"},e7VM:function(e,a,t){"use strict";t.r(a),t.d(a,"_frontmatter",(function(){return l})),t.d(a,"default",(function(){return d}));var n=t("Fcif"),s=t("+I+c"),i=t("/FXl"),r=t("TjRS"),l=(t("aD51"),{});void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"validators/custom-validators-async.mdx"}});var o={_frontmatter:l},c=r.a;function d(e){var a=e.components,r=Object(s.a)(e,["components"]);return Object(i.b)(c,Object(n.a)({},o,r,{components:a,mdxType:"MDXLayout"}),Object(i.b)("h1",{id:"custom-validators-asynchronous"},"Custom validators asynchronous"),Object(i.b)("p",null,"In some scenarios you need to implement async validations, that's it a validation that won't return the result straight forward, for instance\na validation that need to make a request to a rest-api and cannot provide the result until it gets the response from server."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"Prior to learn about async validations, take your time and learn how to deal with ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"/fonk-doc/validators/custom-validators-sync"}),"synchronous validations")," there are various topics\ncommon to both validators that are explained in the previous topic section.")),Object(i.b)("h2",{id:"async-field-validator"},"Async Field Validator"),Object(i.b)("p",null,"An async field validator is just a funcion that expects an argument (this argument is an object that contains several fields),\nand returns a promise that will contain a validation result once resolved."),Object(i.b)("p",null,"Depending on the use case (e.g. is hitting a global rest api or a given domain specific rest api), it could be reusable or not."),Object(i.b)("h3",{id:"disecting-an-async-validators"},"Disecting an async validators"),Object(i.b)("p",null,"The definition of an asynchronous field validator:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"FieldValidationArgs"),": This is passed as a single argument in the validator",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"value"),": current field value."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"values"),": form / record values (all fields)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"customArgs"),": we can pass custom arguments to our validator, this allow us to create flexible and configurable\nvalidators (e.g. in a min-lenght validator we can pass as customArgument a number indicating the minlenght allowed,\nor if we have a password / repeat password validator we can pass the id of the password field to the repeat password\nfield)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"message"),": you can override here the error message that the validator returns in case of failure. You can inject\nin a message ",Object(i.b)("em",{parentName:"li"},"parameters")," to be interpolated by the validator (e.g. 'string must be at least {{minlength}}'),\nin some validators there may be more than one error message defined, in that case we can pass an array of strings."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Promise<ValidationResult",">"),": once the validator has been executed it returns a ",Object(i.b)("em",{parentName:"li"},"Promise<ValidationResult",">"),",\nonce the promise gets resolved:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"If the validation succeeds, you get as return value a ",Object(i.b)("em",{parentName:"li"},"ValidationResult")," where it's field ",Object(i.b)("em",{parentName:"li"},"succeeded")," is true."),Object(i.b)("li",{parentName:"ul"},"If the validation fails, you get as return value a ",Object(i.b)("em",{parentName:"li"},"ValidationResult")," where it's field ",Object(i.b)("em",{parentName:"li"},"succeeded")," is false,\na ",Object(i.b)("em",{parentName:"li"},"message")," where you get the error message (user friendly) and a ",Object(i.b)("em",{parentName:"li"},"type")," field that indicates the validator that\nfailed.")))))),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript"}),"export interface FieldValidatorArgs {\n  value: any;\n  values?: any;\n  customArgs?: any;\n  message?: string | string[];\n}\n\nexport interface ValidationResult {\n  type: string;\n  succeeded: boolean;\n  message: string;\n}\n\nexport type FieldValidationFunctionAsync = (\n  fieldValidatorArgs: FieldValidatorArgs\n) => Promise<ValidationResult>;\n")),Object(i.b)("h3",{id:"learning-by-example"},"Learning by Example"),Object(i.b)("p",null,"The best way to learn how to implementing an async validator is just by doing it so."),Object(i.b)("p",null,"Let's get started , we have a signup field and we ask the user to enter a new user id,\nthis user Id has to be new, it cannot exists in our system (in this case we will\ncheck that the userId does not exists in github using the Github rest api)."),Object(i.b)("p",null,"We will start simple, in order to check we only need use the ",Object(i.b)("em",{parentName:"p"},"value")," we\ndon't need the rest of optional params: ",Object(i.b)("em",{parentName:"p"},"values"),", ",Object(i.b)("em",{parentName:"p"},"customArgs"),", ",Object(i.b)("em",{parentName:"p"},"message"),", we will follow a TDD like approach\nwe will create the validator always failing (returning a failed validation result)."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-javascript"}),"const validatorType = 'GITHUB_USER_EXISTS';\n\nexport const myValidator = fieldValidatorArgs => {\n  const validationResult = {\n    succeeded: false,\n    type: validatorType,\n    message: 'The username exists on Github',\n  };\n\n  return Promise.resolve(validationResult);\n};\n")),Object(i.b)("p",null,"Cool, we got a validator that always fails, now is time to inject our logic; we just want\nto validate that the login Id doesn't exists on Github."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-diff"}),"const validatorType = 'GITHUB_USER_EXISTS';\n\nexport const myValidator = fieldValidatorArgs => {\n+ const { value } = fieldValidatorArgs;\n  const validationResult = {\n    succeeded: false,\n    type: validatorType,\n    message: 'The username exists on Github',\n  };\n\n- return Promise.resolve(validationResult);\n+ return fetch(`https://api.github.com/users/${value}`).then(response => {\n+   // Status 404, User does not exists, so the given user is valid\n+   // Status 200, meaning user exists, so the given user is not valid\n+   return response.status === 404\n+     ? {\n+         ...validationResult,\n+         succeeded: true,\n+         message: '',\n+       }\n+     : validationResult;\n+ });\n};\n\n")),Object(i.b)("p",null,"Let's add some additional changes to allow the error message to be customized (you can check an step by step guided solution\nin the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"/fonk-doc/validators/custom-validators-sync"}),"synchronous validation section"),")."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-diff"}),"const validatorType = 'GITHUB_USER_EXISTS';\n\n+ let defaultMessage = 'The username exists on Github';\n+ export const setErrorMessage = message => (defaultMessage = message);\n\nexport const myValidator = fieldValidatorArgs => {\n- const { value } = fieldValidatorArgs;\n+ const { value, message = defaultMessage } = fieldValidatorArgs;\n\n  const validationResult = {\n    succeeded: false,\n    type: validatorType,\n-   message: 'The username exists on Github',\n+   message,\n  };\n\n  return fetch(`https://api.github.com/users/${value}`).then(response => {\n    // Status 404, User does not exists, so the given user is valid\n    // Status 200, meaning user exists, so the given user is not valid\n    return response.status === 404\n      ? {\n          ...validationResult,\n          succeeded: true,\n          message: '',\n        }\n      : validationResult;\n  });\n};\n\n")),Object(i.b)("p",null,Object(i.b)("img",{alt:"async-validator",src:t("3Zug")})),Object(i.b)("p",null,"Check here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/vanilla/js/async-validator"}),"Plain Vanilla JS"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/vanilla/ts/async-validator"}),"Plain Vanilla TS"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/react-final-form/js/async-validator"}),"React + React Final Form JS"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/react-final-form/ts/async-validator"}),"React + React Final Form TS"),".")),Object(i.b)("h2",{id:"asynchronous-record-validator"},"Asynchronous Record Validator"),Object(i.b)("p",null,"An asynchronous record validator is a validation that is not tied up to an specific field, is usually something that we trigger\nwhen the user hits submit, and previous to send the information to the server."),Object(i.b)("p",null,"Record validations usually are not highly reusable functions, they are tied up to the domain of the form to be evaluated."),Object(i.b)("h3",{id:"disecting-a-record-validator"},"Disecting a record validator"),Object(i.b)("p",null,"The definition of an asynchronous record validation:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"RecordValidationArgs"),": This is passed as a single argument in the validator.",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"values"),": form / record values (all fields)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"message"),": you can override here the error message that the validator returns in case of failure. You can inject\nin a message ",Object(i.b)("em",{parentName:"li"},"parameters")," to be interpolated by the validator (e.g. 'string must be at least {{minlength}}'),\nin some validators there may be more than one error message defined, in that case we can pass an array of strings."))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Promise<ValidationResult",">"),": once the validator has been executed it returns a ",Object(i.b)("em",{parentName:"li"},"Promise<ValidationResult",">"),",\nonce the promise gets resolved:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"If the validation succeeds, you get as return value a ",Object(i.b)("em",{parentName:"li"},"ValidationResult")," where it's field ",Object(i.b)("em",{parentName:"li"},"succeeded")," is true."),Object(i.b)("li",{parentName:"ul"},"If the validation fails, you get as return value a ",Object(i.b)("em",{parentName:"li"},"ValidationResult")," where it's field ",Object(i.b)("em",{parentName:"li"},"succeeded")," is false,\na ",Object(i.b)("em",{parentName:"li"},"message")," where you get the error message (user friendly) and a ",Object(i.b)("em",{parentName:"li"},"type")," field that indicates the validator that\nfailed.")))),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-typescript"}),"export interface RecordValidatorArgs {\n  values: any;\n  message?: string | string[];\n}\n\nexport interface ValidationResult {\n  type: string;\n  succeeded: boolean;\n  message: string;\n}\n\nexport type RecordValidationFunctionAsync = (\n  recordValidatorArgs: RecordValidatorArgs\n) => Promise<ValidationResult>;\n")),Object(i.b)("h3",{id:"learning-by-example-1"},"Learning by Example"),Object(i.b)("p",null,"We have the following scenario: a third party rest-api where we can submit requests: this request will be queued up and it could take minutes or hours to get resolved\n(prior to process data this api's will check against a local database in real time in order to check if the information submitted is correct)."),Object(i.b)("p",null,"This could impact in a severe way to the usability of the application, our backend developers have decided to implement system that will hit a cache, and provide\na real time response that in 90% of the case will be accurate (or at least will trap 90% of the user form errors)."),Object(i.b)("p",null,"The model of the form that we want to manage is:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-javascript"}),"interface Process {\n  name: string;\n  cachedResult: string;\n}\n")),Object(i.b)("p",null,"The server validation call will have the following signature (we will emulate it in our example)."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-javascript"}),"const resolveProcess = (): Promise<string> => {\n  const time = Math.random() * 1000;\n  return time <= 900 ? '✅' : '❌';\n};\n")),Object(i.b)("p",null,"The validator that we will implement:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-javascript"}),"import { resolveProcessFromBackend } from './api';\n\nexport const processValidator = ({ values }) =>\n  resolveProcessFromBackend().then(data => {\n    const succeeded = values.cachedResult === data;\n    return {\n      succeeded,\n      message: succeeded\n        ? ''\n        : `Please, review the process. The real result was ${data}`,\n      type: 'RECORD_PROCESS',\n    };\n  });\n")),Object(i.b)("p",null,Object(i.b)("img",{alt:"async-record-validator",src:t("Xz34")})),Object(i.b)("p",null,"Check here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/docs/validators/js/vanilla/async-record-validator"}),"Plain Vanilla JS"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/docs/validators/ts/vanilla/async-record-validator"}),"Plain Vanilla TS"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/docs/validators/js/react-final-form/async-record-validator"}),"React + React Final Form JS"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"https://codesandbox.io/s/github/lemoncode/fonk/tree/master/examples/docs/validators/ts/react-final-form/async-record-validator"}),"React + React Final Form TS"),".")),Object(i.b)("h3",{id:"next-steps"},"Next steps"),Object(i.b)("p",null,"You have successfully completed the custom validators module."),Object(i.b)("p",null,"You can choose wether to jump into ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"/fonk-doc/react-final-form"}),"React Final Forms Integration"),"."),Object(i.b)("p",null,"Or ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"/fonk-doc/messages/internationalization"}),"internationalization")))}void 0!==d&&d&&d===Object(d)&&Object.isExtensible(d)&&!d.hasOwnProperty("__filemeta")&&Object.defineProperty(d,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"validators/custom-validators-async.mdx"}}),d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---validators-custom-validators-async-mdx-e624c5f0d6e6f9e0e053.js.map